/* ******************************************************************
* Sparen's Danmakufu ph3 Application Monitoring System
* For use with Touhou Danmakufu ph3
* (C) Sparen of Iria 2018
* Version 0.2-pre
****************************************************************** */

/* ******************************************************************
* This script is meant to be run in parallel with a stage script or 
* lower. Set up this system in @Loading of your preferred script
* using LoadScript(), SetCommonData(), and StartScript().
****************************************************************** */

// Global Variables used regardless of which tracking mechanisms are enabled
let currdir = GetCurrentScriptDirectory();
let starttime = GetCurrentDateTimeS(); // Log start time for use in output report
let player = GetPlayerID(); // Player #ID, used in output report

// Variables to be updated
let elapsedtime = 0;
let finished = false;
let finished_fps = false;
let finished_graze = false;
let finished_score = false;

// Variables to be customized
let EVENT_DNHAPM_FINALIZE; // Event to call via NotifyEvent/NotifyEventAll when the user wishes to generate the output report.
let OUTPUT_DIRECTORY; // Directory to output the report to
let SCRIPT_NAME; // Name of the script being monitored
let ENABLE_AGGREGATE; // Whether or not to aggregate all data in directory when making graphs
let GRAPH_SCALE; // Scale of the x axis on the graph. To be implemented later.
let AGGREGATE_LINE_OPACITY; // Opacity of the paths representing former data points.

let USER_TEXT; // User defined text
let USER_NOTE_SLOTS; // Number of User Note slots to use
let EVENT_USER_NOTE; // Event to call via NotifyEvent/NotifyEventAll when the user wishes to log a note
let ENABLE_NOTE_LINE; // Whether or not to render a line up through the graph at a note

// Feature Set Customization
let FEATURE_FPS_ENABLE; // Enable or disable FPS logging
let FEATURE_FPS_UPDATEFREQ; // Update frequency, in frames.
let FEATURE_FPS_LINECOLOR; // Color of the line, in HTML supported color

let FEATURE_GRAZE_ENABLE; // Enable or disable Graze logging
let FEATURE_GRAZE_UPDATEFREQ; // Update frequency, in frames.
let FEATURE_GRAZE_LINECOLOR; // Color of the line, in HTML supported color

let FEATURE_SCORE_ENABLE; // Enable or disable Score logging
let FEATURE_SCORE_UPDATEFREQ; // Update frequency, in frames.
let FEATURE_SCORE_LINECOLOR; // Color of the line, in HTML supported color

@Loading {
    if (!IsCommonDataAreaExists("dnhapm")) {
        CreateCommonDataArea("dnhapm");
    }
}

@Initialize {
    WriteLog("DNHAPM: Now running");
    // Load customizable variables
    EVENT_DNHAPM_FINALIZE = GetAreaCommonData("dnhapm", "FinalizeEvent", EV_USER_STAGE + 2048);
    OUTPUT_DIRECTORY = GetAreaCommonData("dnhapm", "OutputDirectory", currdir ~ "./dnhapm-output/");
    SCRIPT_NAME = GetAreaCommonData("dnhapm", "ScriptName", "--Unnamed Script--");
    ENABLE_AGGREGATE = GetAreaCommonData("dnhapm", "EnableAggregate", true);
    GRAPH_SCALE = GetAreaCommonData("dnhapm", "GraphScale", 2);
    AGGREGATE_LINE_OPACITY = GetAreaCommonData("dnhapm", "AggregateLineOpacity", 0.25);

    USER_TEXT = GetAreaCommonData("dnhapm", "UserText", "");
    USER_NOTE_SLOTS = GetAreaCommonData("dnhapm", "UserNoteSlots", 2);
    EVENT_USER_NOTE = GetAreaCommonData("dnhapm", "UserNoteEvent", EV_USER_STAGE + 2050);
    ENABLE_NOTE_LINE = GetAreaCommonData("dnhapm", "EnableNoteLine", true);

    FEATURE_FPS_ENABLE = GetAreaCommonData("dnhapm", "FPSEnable", true);
    FEATURE_FPS_UPDATEFREQ = GetAreaCommonData("dnhapm", "FPSUpdateFreq", 10);
    FEATURE_FPS_LINECOLOR = GetAreaCommonData("dnhapm", "FPSLineColor", "#2266FF");

    FEATURE_GRAZE_ENABLE = GetAreaCommonData("dnhapm", "GrazeEnable", true);
    FEATURE_GRAZE_UPDATEFREQ = GetAreaCommonData("dnhapm", "GrazeUpdateFreq", 10);
    FEATURE_GRAZE_LINECOLOR = GetAreaCommonData("dnhapm", "GrazeLineColor", "#887777");

    FEATURE_SCORE_ENABLE = GetAreaCommonData("dnhapm", "ScoreEnable", true);
    FEATURE_SCORE_UPDATEFREQ = GetAreaCommonData("dnhapm", "ScoreUpdateFreq", 10);
    FEATURE_SCORE_LINECOLOR = GetAreaCommonData("dnhapm", "ScoreLineColor", "#FF5555");

    //Initialize non-event based trackers
    if (FEATURE_FPS_ENABLE) {
        APM_StartFPS;
    }
    if (FEATURE_GRAZE_ENABLE) {
        APM_StartGraze;
    }
    if (FEATURE_SCORE_ENABLE) {
        APM_StartScore;
    }
}

// We must catch all notable events.
@Event {
    alternative(GetEventType())
    case(EVENT_DNHAPM_FINALIZE) {
        GenerateReport;
    }
    case(EVENT_USER_NOTE) {
        let arg = GetEventArgument(0); // Number of event, Contents of event
        LogNote(arg[0], arg[1]);
    }
}

@MainLoop {
    elapsedtime += 1; // update counter
    yield;
}

/* ============================================================================== */
/* ================================ Note Logging ================================ */
/* ============================================================================== */
// For now, we will store notes per-run and will not save them to disk.
//let notefile = ObjFile_Create(OBJ_FILE_TEXT);
//let notefilepath = OUTPUT_DIRECTORY ~ "apmnote-" ~ starttime ~ ".txt";
//ObjFile_OpenNW(notefile, notefilepath);
let notestring = "";

function LogNote(key, val) {
    let newnote = IntToString(elapsedtime) ~ "," ~ key ~ "," ~ val;
    //ObjFileT_AddLine(notefile, newnote);
    //ObjFile_Store(notefile);
    notestring = notestring ~ newnote ~ "|";
}

// Takes the notes and generates SVG paths and text for them.
function NotesToSVG {
    WriteLog("NotesToSVG: Writing with: " ~ notestring);
    let svg = "";
    // Parse note by new line, then by comma.
    let notes = SplitString(notestring, "|");
    // Must do all paths, then all notes. Otherwise the paths will render over the text.
    ascent(i in 0..length(notes)) {
        if (notes[i] != "") {
            let note = SplitString(notes[i], ",");
            let notex = 64 + atoi(note[0]) * GRAPH_SCALE/60;
            let notey = 328 + atoi(note[1]) * 12;
            let notepath = "<path d=\"M " ~ ToString(notex) ~ " 304 V " ~ ToString(notey) ~ " H " ~ ToString(notex + 2) ~ "\" stroke=\"#DDDDDD\" stroke-width=\"1\" fill=\"none\"></path>";
            let notepath2 = "";
            // If the note line is enabled, add another path upwards.
            if (ENABLE_NOTE_LINE) {
                notepath2 = "<path d=\"M " ~ ToString(notex) ~ " 304 V 0\" stroke=\"#EEEEEE\" stroke-width=\"1\" fill=\"none\"></path>";
            }
            svg = svg ~ notepath ~ notepath2;
        }
    }
    ascent(i in 0..length(notes)) {
        if (notes[i] != "") {
            let note = SplitString(notes[i], ",");
            let notex = 64 + atoi(note[0]) * GRAPH_SCALE/60;
            let notey = 328 + atoi(note[1]) * 12;
            let notetext = "<text x=\"" ~ ToString(notex + 4) ~ "\" y=\"" ~ ToString(notey) ~ "\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"start\" dominant-baseline=\"central\">";
            notetext = notetext ~ note[2];
            notetext = notetext ~ "</text>";
            svg = svg ~ notetext;
        }
    }
    return svg;
}

/* ============================================================================= */
/* ================================ FPS Logging ================================ */
/* ============================================================================= */
task APM_StartFPS {
    // Create output file
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    let outputfilepath = OUTPUT_DIRECTORY ~ "apmfps-" ~ SCRIPT_NAME ~ "_" ~ player ~ "_" ~ starttime ~ ".csv";
    ObjFile_OpenNW(outputfile, outputfilepath);
    let csvlog = ""; // CSV log
    let counter = 0;
    while(!finished) {
        let cfps = GetCurrentFps();
        csvlog = csvlog ~ vtos("1.2f", cfps) ~ ",";
        // If csvlog is getting too long, push it to the File Object
        if (counter % 128 == 0) {
            ObjFileT_AddLine(outputfile, csvlog);
            csvlog = "";
        }
        counter += 1;
        loop(FEATURE_FPS_UPDATEFREQ){yield;}
    }
    // Flush to file
    ObjFileT_AddLine(outputfile, csvlog);
    ObjFile_Store(outputfile);
    WriteLog("APM_StartFPS: Wrote CSV to " ~ outputfilepath);
    Obj_Delete(outputfile);
    // yield once before marking as complete
    yield;
    finished_fps = true;
    WriteLog("APM_StartFPSDEBUG: Finished");
}

// Returns the SVG chart for FPS in its entirety.
function APM_ChartGenFPS {
    WriteLog("APM_ChartGenFPS: Starting.");
    // Determine max value of interest, max time, and paths to render from the files.
    let cgcommon = APM_ChartGenCommon("apmfps", FEATURE_FPS_UPDATEFREQ, FEATURE_FPS_LINECOLOR);
    let maxfps = cgcommon[0];
    let maxtime = cgcommon[1];
    let paths = GetAreaCommonData("dnhapm", "cgcpath_apmfps", []);
    // Chart Basics 
    let svg = "<div class=\"bodydiv\">" ~ SVGChartGen(maxtime * FEATURE_FPS_UPDATEFREQ/60);
    // Notes
    svg = svg ~ NotesToSVG;
    // X Axis Labels
    svg = svg ~ SVGXAxisGen(maxtime * FEATURE_FPS_UPDATEFREQ/60);
    // Y Axis Labels
    svg = svg ~ SVGYAxisGen(maxfps, "FPS");
    // Add paths
    ascent(i in 0..length(paths)) {
        svg = svg ~ paths[i];
    }
    // Close SVG
    svg = svg ~ "</svg>";
    svg = svg ~ "<p>Logged a maximum of " ~ IntToString(maxtime) ~ " data points spanning " ~ ToString(maxtime * FEATURE_FPS_UPDATEFREQ/60) ~ " seconds.</p>";
    svg = svg ~ "<p>Logged a maximum FPS of " ~ vtos("1.2f", maxfps) ~ ".</p></div>";  
    return svg;
}

/* =============================================================================== */
/* ================================ Graze Logging ================================ */
/* =============================================================================== */
task APM_StartGraze {
    // Create output file
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    let outputfilepath = OUTPUT_DIRECTORY ~ "apmgraze-" ~ SCRIPT_NAME ~ "_" ~ player ~ "_" ~ starttime ~ ".csv";
    ObjFile_OpenNW(outputfile, outputfilepath);
    let csvlog = ""; // CSV log
    let counter = 0;
    while(!finished) {
        let cfps = GetGraze();
        csvlog = csvlog ~ vtos("1.2f", cfps) ~ ",";
        // If csvlog is getting too long, push it to the File Object
        if (counter % 128 == 0) {
            ObjFileT_AddLine(outputfile, csvlog);
            csvlog = "";
        }
        counter += 1;
        loop(FEATURE_GRAZE_UPDATEFREQ){yield;}
    }
    // Flush to file
    ObjFileT_AddLine(outputfile, csvlog);
    ObjFile_Store(outputfile);
    WriteLog("APM_StartGraze: Wrote CSV to " ~ outputfilepath);
    Obj_Delete(outputfile);
    // yield once before marking as complete
    yield;
    finished_graze = true;
    WriteLog("APM_StartGraze: Finished");
}

// Returns the SVG chart for Graze in its entirety.
function APM_ChartGenGraze {
    WriteLog("APM_ChartGenGraze: Starting.");
    // Determine max value of interest, max time, and paths to render from the files.
    let cgcommon = APM_ChartGenCommon("apmgraze", FEATURE_GRAZE_UPDATEFREQ, FEATURE_GRAZE_LINECOLOR);
    let maxgraze = cgcommon[0];
    let maxtime = cgcommon[1];
    let paths = GetAreaCommonData("dnhapm", "cgcpath_apmgraze", []);
    // Chart Basics 
    let svg = "<div class=\"bodydiv\">" ~ SVGChartGen(maxtime * FEATURE_GRAZE_UPDATEFREQ/60);
    // Notes
    svg = svg ~ NotesToSVG;
    // X Axis Labels
    svg = svg ~ SVGXAxisGen(maxtime * FEATURE_GRAZE_UPDATEFREQ/60);
    // Y Axis Labels
    svg = svg ~ SVGYAxisGen(maxgraze, "");
    // Add paths
    ascent(i in 0..length(paths)) {
        svg = svg ~ paths[i];
    }
    // Close SVG
    svg = svg ~ "</svg>";
    svg = svg ~ "<p>Logged a maximum of " ~ IntToString(maxtime) ~ " data points spanning " ~ ToString(maxtime * FEATURE_GRAZE_UPDATEFREQ/60) ~ " seconds.</p>";
    svg = svg ~ "<p>Logged a maximum Graze of " ~ IntToString(maxgraze) ~ ".</p></div>";  
    return svg;
}

/* =============================================================================== */
/* ================================ Score Logging ================================ */
/* =============================================================================== */
task APM_StartScore {
    // Create output file
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    let outputfilepath = OUTPUT_DIRECTORY ~ "apmscore-" ~ SCRIPT_NAME ~ "_" ~ player ~ "_" ~ starttime ~ ".csv";
    ObjFile_OpenNW(outputfile, outputfilepath);
    let csvlog = ""; // CSV log
    let counter = 0;
    while(!finished) {
        let cfps = GetScore();
        csvlog = csvlog ~ vtos("1.2f", cfps) ~ ",";
        // If csvlog is getting too long, push it to the File Object
        if (counter % 128 == 0) {
            ObjFileT_AddLine(outputfile, csvlog);
            csvlog = "";
        }
        counter += 1;
        loop(FEATURE_SCORE_UPDATEFREQ){yield;}
    }
    // Flush to file
    ObjFileT_AddLine(outputfile, csvlog);
    ObjFile_Store(outputfile);
    WriteLog("APM_StartScore: Wrote CSV to " ~ outputfilepath);
    Obj_Delete(outputfile);
    // yield once before marking as complete
    yield;
    finished_score = true;
    WriteLog("APM_StartScore: Finished");
}

// Returns the SVG chart for Score in its entirety.
function APM_ChartGenScore {
    WriteLog("APM_ChartGenScore: Starting.");
    // Determine max value of interest, max time, and paths to render from the files.
    let cgcommon = APM_ChartGenCommon("apmscore", FEATURE_SCORE_UPDATEFREQ, FEATURE_SCORE_LINECOLOR);
    let maxscore = cgcommon[0];
    let maxtime = cgcommon[1];
    let paths = GetAreaCommonData("dnhapm", "cgcpath_apmscore", []);
    // Chart Basics 
    let svg = "<div class=\"bodydiv\">" ~ SVGChartGen(maxtime * FEATURE_SCORE_UPDATEFREQ/60);
    // Notes
    svg = svg ~ NotesToSVG;
    // X Axis Labels
    svg = svg ~ SVGXAxisGen(maxtime * FEATURE_SCORE_UPDATEFREQ/60);
    // Y Axis Labels
    svg = svg ~ SVGYAxisGen(maxscore, "");
    // Add paths
    ascent(i in 0..length(paths)) {
        svg = svg ~ paths[i];
    }
    // Close SVG
    svg = svg ~ "</svg>";
    svg = svg ~ "<p>Logged a maximum of " ~ IntToString(maxtime) ~ " data points spanning " ~ ToString(maxtime * FEATURE_SCORE_UPDATEFREQ/60) ~ " seconds.</p>";
    svg = svg ~ "<p>Logged a maximum Score of " ~ IntToString(maxscore) ~ ".</p></div>";  
    return svg;
}

/* =================================================================================== */
/* ================================ Report Generation ================================ */
/* =================================================================================== */

// Function used by all file-reading graph generation functions.
// Parses all relevant files in current directory to retrieve max value of interest (for y axis), max time (for x axis), and an array of paths to put on the graph.
// Returns [maxval, maxtime]
// Parameters: apmtype (apmscore/apmfps/...)
function APM_ChartGenCommon(apmtype, updfreq, linecolor) {
    let paths = [];
    // First, we will determine the scale of the x and y axes and log all of the necessary files.
    let maxval = 0; // Maximum value of interest 
    let maxtime = 0; // Number of DATA POINTS collected - will be scaled later
    let currfilepath = OUTPUT_DIRECTORY ~ apmtype ~ "-" ~ SCRIPT_NAME ~ "_" ~ player ~ "_" ~ starttime ~ ".csv"; // Current run, for later reference
    let filepathlist = GetFilePathList(OUTPUT_DIRECTORY);
    ascent(i in 0..length(filepathlist)) {
        // First, retrieve the file name
        let filename = parseFileName(filepathlist[i]);
        //WriteLog("APM_ChartGenScore DEBUG: testing on " ~ filename);
        // We only read the file if aggregating and a val file, or if it's the file we just set up.
        if (filename[0..length(apmtype)] == apmtype && ENABLE_AGGREGATE || (filename == currfilepath)) {
            //WriteLog("APM_ChartGenScore DEBUG: running on " ~ filename);
            // See if this one sets a new maxval
            let filedatapoints = CSVtoArray(filepathlist[i]);
            let filemaxval = maxarr(filedatapoints);
            if (filemaxval > maxval) {maxval = filemaxval;}
            // See if this one sets a new maxtime
            if (length(filedatapoints) > maxtime) {maxtime = length(filedatapoints);}
            // Generate path. If filepathlist[i] is the current file, then opacity is set to 1, AGGREGATE_LINE_OPACITY otherwise.
            let opacity = 1;
            if (filepathlist[i] != currfilepath) {opacity = AGGREGATE_LINE_OPACITY;}
            let newpath = "<path d=\"M 64 304 ";
            // Iterate over the data points. Recall that by default, a second is one pixel.
            // Also recall that each data point is updfreq frames apart.
            let basex = 64;
            ascent(j in 0..length(filedatapoints)) {
                let nodex = basex + j * updfreq/60 * GRAPH_SCALE;
                let nodey = 304 - 300 * ator(filedatapoints[j])/maxval;
                newpath = newpath ~ "L " ~ ToString(nodex) ~ " " ~ ToString(nodey) ~ " ";
            }
            newpath = newpath ~ "\" stroke=\"" ~ linecolor ~ "\" stroke-width=\"1\" fill=\"none\" opacity=\"" ~ ToString(opacity) ~ "\"></path>";
            paths = paths ~ [newpath];
        }
    }
    // Return path, maxval, and maxtime data
    SetAreaCommonData("dnhapm", "cgcpath_" ~ apmtype, paths);
    return [maxval, maxtime];
}

// Returns the SVG chart header. Helper function.
// Takes the amount of time to display on the graph in seconds.
function SVGChartGen(time) {
    let svg_width = time * GRAPH_SCALE + 128; // By default, a second is one pixel. 64 pixel buffer for left sidebar, 64 for right sidebar
    let svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" ~ ToString(svg_width) ~ "\" height=\"" ~ IntToString(328 + 12 * USER_NOTE_SLOTS) ~ "\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">";
    svg = svg ~ "<path d=\"M 64 304 H " ~ ToString(svg_width) ~ "\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
    svg = svg ~ "<path d=\"M 64 304 V 0\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
    return svg;
}

// Returns the x axis with as many 48-pixel spaced labels as possible. Helper function.
// Takes the amount of time to display on the graph in seconds.
function SVGXAxisGen(time) {
    let svg = "";
    // Plot the labels on the x axis every 48 * GRAPH_SCALE seconds (default, every 48 pixels). Needs to be a multiple of 12 pixels to avoid awful rounding.
    let totaltimesec = time * GRAPH_SCALE; // Number of pixels we can draw in
    let xaxisctr = 0; // Position in time per label. Unit is NOT pixels.
    while (xaxisctr * GRAPH_SCALE < totaltimesec) {
        // Tick on line
        svg = svg ~ "<path d=\"M " ~ ToString(64 + xaxisctr * GRAPH_SCALE) ~ " 302 V 308\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
        // Text Label
        svg = svg ~ "<text x=\"" ~ ToString(64 + xaxisctr * GRAPH_SCALE) ~ "\" y=\"316\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"middle\" dominant-baseline=\"central\">";
        let minutes = truncate(xaxisctr/60);
        let seconds = truncate(xaxisctr) % 60;
        svg = svg ~ IntToString(minutes) ~ "m" ~ IntToString(seconds) ~ "s";
        svg = svg ~ "</text>";
        xaxisctr += 48 / GRAPH_SCALE;
    }
    return svg;
}

// Returns the y axis with labels. Helper function.
// Takes the max value (for label scaling) and a supplementary label.
function SVGYAxisGen(maxval, label) {
    let svg = "";
    // Add y axis labels. Note: 304 pixels worth of height to play with. We will want exactly 10 labels.
    ascent(i in 0..10) {
        // Tick on line
        svg = svg ~ "<path d=\"M 60 " ~ ToString(304 - 300 * i/9) ~ " H 66\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
        // Text Label
        svg = svg ~ "<text x=\"54\" y=\"" ~ ToString(304 - 300 * i/9) ~ "\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"end\" dominant-baseline=\"central\">";
        svg = svg ~ vtos("1.2f", maxval/9 * i) ~ label;
        svg = svg ~ "</text>";
    }
    return svg;
}

/* *************************************************************************
* CSVtoArray() -- Takes a newline and comma delimited file and converts it to an array.
* Param: filepath (string) - File handle of modified CSV file
* Return: array of string values
************************************************************************* */
function CSVtoArray(filepath) {
    WriteLog("CSVtoArray: Running on " ~ filepath);
    let handle = ObjFile_Create(OBJ_FILE_TEXT);
    let status = ObjFile_Open(handle, filepath);
    while (!status) {
        WriteLog("CSVtoArray: Reading file " ~ filepath ~ " failed.");
        status = ObjFile_Open(handle, filepath);
        yield;
    }
    WriteLog("CSVtoArray: Successfully read file " ~ filepath ~ ".");

    let toreturn = [];
    ascent(i in 0..ObjFileT_GetLineCount(handle)) { // For every line
        let line = ObjFileT_GetLineText(handle, i + 1); // Recall that lines are 1-indexed
        let split = SplitString(line, ",");
        ascent(j in 0..length(split)) {
            if (split[j] != "") {
                toreturn = toreturn ~ [ator(split[j])];
            }
        }
    }
    Obj_Delete(handle);
    return toreturn;
}

task GenerateReport() {
    finished = true;
    yield; //Wait for all tasks fo terminate and flush

    // Begin by creating our output HTML file.
    let outputfilepath = OUTPUT_DIRECTORY ~ SCRIPT_NAME ~ "_" ~ player ~ "_" ~ starttime ~ ".html";
    WriteLog("GenerateReport: Will write to " ~ outputfilepath);
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    ObjFile_OpenNW(outputfile, outputfilepath);

    // First, write our headers
    let headerhtml = "<!DOCTYPE html><html lang=\"en-us\"><meta charset=\utf-8\"><title>Danmakufu APM for " ~ SCRIPT_NAME ~ "</title>";
    ObjFileT_AddLine(outputfile, headerhtml);

    // Second, add CSS
    let csshtml = "<style>body {font-family: \"Helvetica\";} .header {padding: 4px; background-color: #4466DD; color: white; border-left: 8px solid #88DDFF;} .bodydiv {padding-left: 8px;}</style>";
    ObjFileT_AddLine(outputfile, csshtml);

    // Begin body
    let bodystarthtml = "<body>";
    ObjFileT_AddLine(outputfile, bodystarthtml);

    // Write Opening Header
    let openingheaderhtml = "<h1 class=\"header\">Danmakufu APM Report for script: " ~ SCRIPT_NAME ~ "</h1>" ~
        "<div class=\"bodydiv\"><p>Start Time: " ~ starttime[0..4] ~ " " ~ starttime[4..6] ~ " " ~ starttime[6..8] ~ " " ~ starttime[8..10] ~ ":" ~ starttime[10..12] ~ ":" ~ starttime[12..14] ~ "</p><p>Player ID: " ~ player ~ "</p>";
    openingheaderhtml = openingheaderhtml ~ ToString(USER_TEXT) ~ "</div>";
    ObjFileT_AddLine(outputfile, openingheaderhtml);

    // --------------- Start Reporting ---------------

    // Table of Contents
    ObjFileT_AddLine(outputfile, "<div class=\"tableofcontents\"><h2 class=\"header\">Table of Contents</h2><ul>");
    if (FEATURE_FPS_ENABLE) {ObjFileT_AddLine(outputfile, "<li><a href=\"#header_fps\">FPS Monitoring</a></li>");}
    if (FEATURE_GRAZE_ENABLE) {ObjFileT_AddLine(outputfile, "<li><a href=\"#header_graze\">Graze Monitoring</a></li>");}
    if (FEATURE_SCORE_ENABLE) {ObjFileT_AddLine(outputfile, "<li><a href=\"#header_score\">Score Monitoring</a></li>");}
    ObjFileT_AddLine(outputfile, "</ul></div>");

    if (FEATURE_FPS_ENABLE) {
        while (!finished_fps) {yield;} //Wait for file to be written before reading
        ObjFileT_AddLine(outputfile, "<h3 class=\"header\" id=\"header_fps\">FPS Monitoring</h3><div class=\"bodydiv\"><p>Note: FPS values recorded here may be lower than usual due to the overhead caused by the APM.</p></div>");
        ObjFileT_AddLine(outputfile, APM_ChartGenFPS);
    }

    if (FEATURE_GRAZE_ENABLE) {
        while (!finished_graze) {yield;} //Wait for file to be written before reading
        ObjFileT_AddLine(outputfile, "<h3 class=\"header\" id=\"header_graze\">Graze Monitoring</h3>");
        ObjFileT_AddLine(outputfile, APM_ChartGenGraze);
    }

    if (FEATURE_SCORE_ENABLE) {
        while (!finished_score) {yield;} //Wait for file to be written before reading
        ObjFileT_AddLine(outputfile, "<h3 class=\"header\" id=\"header_score\">Score Monitoring</h3>");
        ObjFileT_AddLine(outputfile, APM_ChartGenScore);
    }

    // ---------------  End Reporting  ---------------

    // End Body
    let bodyendhtml = "<body>";
    ObjFileT_AddLine(outputfile, bodyendhtml);

    // End by closing the HTML and writing our output HTML file.
    let endhtml = "</html>";
    ObjFileT_AddLine(outputfile, endhtml);
    ObjFile_Store(outputfile);
    yield;
    Obj_Delete(outputfile);
}

/* ================================================================================== */
/* ================================ Helper Functions ================================ */
/* ================================================================================== */

// Returns max value in array. Assumes string inputs.
// Thankfully DNH allows us to compare strings like so: "3.0" < "2.4"
function maxarr(arr) {
    if (length(arr) == 0) {
        WriteLog("maxarr: Received empty array");
        return -1;
    }
    let maxval = arr[0];
    ascent(i in 0..length(arr)) {
        if (arr[i] >= maxval) {
            maxval = arr[i];
        }
    }
    return ator(maxval);
}

function wait(n) {
    loop(n) {
        yield;
    }
}

function parseFileName(filepath) {
    // Essentially, split by /, get last
    let pathunits = SplitString(filepath, "/");
    return pathunits[length(pathunits) - 1];
}