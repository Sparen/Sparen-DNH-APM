/* ******************************************************************
* Sparen's Danmakufu ph3 Application Monitoring System
* For use with Touhou Danmakufu ph3
* (C) Sparen of Iria 2018
****************************************************************** */

/* ******************************************************************
* This script is meant to be run in parallel with a stage script or 
* lower. Set up this system in @Loading of your preferred script
* using LoadScript(), SetCommonData(), and StartScript().
****************************************************************** */

// Global Variables used regardless of which tracking mechanisms are enabled
let currdir = GetCurrentScriptDirectory();
let starttime = GetCurrentDateTimeS(); // Log start time for use in output report
let player = GetPlayerID(); // Player #ID, used in output report

// Variables to be updated
let elapsedtime = 0;
let finished = false;
let finished_fps = false;

// Variables to be customized
let EVENT_DNHAPM_FINALIZE; // Event to call via NotifyEvent/NotifyEventAll when the user wishes to generate the output report.
let OUTPUT_DIRECTORY; // Directory to output the report to
let SCRIPT_NAME; // Name of the script being monitored
let ENABLE_AGGREGATE; // Whether or not to aggregate all data in directory when making graphs
let GRAPH_SCALE; // Scale of the x axis on the graph. To be implemented later.

// Feature Set Customization
let FEATURE_FPS_ENABLE; // Enable or disable FPS logging
let FEATURE_FPS_UPDATEFREQ; // Update frequency, in frames.
let FEATURE_FPS_LINECOLOR; // Color of the line, in HTML supported color

@Loading {
    if (!IsCommonDataAreaExists("dnhapm")) {
        CreateCommonDataArea("dnhapm");
    }
}

@Initialize {
    WriteLog("DNHAPM: Now running");
    // Load customizable variables
    EVENT_DNHAPM_FINALIZE = GetAreaCommonData("dnhapm", "FinalizeEvent", EV_USER_STAGE + 2048);
    OUTPUT_DIRECTORY = GetAreaCommonData("dnhapm", "OutputDirectory", currdir ~ "./dnhapm-output/");
    SCRIPT_NAME = GetAreaCommonData("dnhapm", "ScriptName", "--Unnamed Script--");
    ENABLE_AGGREGATE = GetAreaCommonData("dnhapm", "EnableAggregate", true);
    GRAPH_SCALE = GetAreaCommonData("dnhapm", "GraphScale", 1);

    FEATURE_FPS_ENABLE = GetAreaCommonData("dnhapm", "FPSEnable", true);
    FEATURE_FPS_UPDATEFREQ = GetAreaCommonData("dnhapm", "FPSUpdateFreq", 10);
    FEATURE_FPS_LINECOLOR = GetAreaCommonData("dnhapm", "FPSLineColor", "#2266FF");

    //Initialize non-event based trackers
    if (FEATURE_FPS_ENABLE) {
        APM_StartFPS;
    }
}

// We must catch all notable events.
@Event {
    alternative(GetEventType())
    case(EVENT_DNHAPM_FINALIZE) {
        GenerateReport;
    }
}

@MainLoop {
    elapsedtime += 1; // update counter
    yield;
}

/* ============================================================================= */
/* ================================ FPS Logging ================================ */
/* ============================================================================= */
task APM_StartFPS {
    // Create output file
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    let outputfilepath = OUTPUT_DIRECTORY ~ "apmfps-" ~ starttime ~ ".csv";
    ObjFile_OpenNW(outputfile, outputfilepath);
    let csvlog = ""; // CSV log
    let counter = 0;
    while(!finished) {
        let cfps = GetCurrentFps();
        csvlog = csvlog ~ vtos("1.2f", cfps) ~ ",";
        // If csvlog is getting too long, push it to the File Object
        if (counter % 128 == 0) {
            ObjFileT_AddLine(outputfile, csvlog);
            csvlog = "";
        }
        counter += 1;
        loop(FEATURE_FPS_UPDATEFREQ){yield;}
    }
    // Flush to file
    ObjFileT_AddLine(outputfile, csvlog);
    ObjFile_Store(outputfile);
    WriteLog("APM_StartFPS: Wrote CSV to " ~ outputfilepath);
    Obj_Delete(outputfile);
    // yield once before marking as complete
    yield;
    finished_fps = true;
    WriteLog("APM_StartFPSDEBUG: Finished");
}

// Returns the SVG chart for FPS in its entirety.
function APM_ChartGenFPS {
    WriteLog("APM_ChartGenFPS: Starting.");
    let svg = SVGChartGen;
    let paths = [];
    // Parse files 
    let maxfps = 0;
    let filepath = OUTPUT_DIRECTORY ~ "apmfps-" ~ starttime ~ ".csv"; // Current run
    // If we are using Aggregate, then we iterate over all files in directory with "apmfps-" at start of name.
    //TODO
    // Otherwise just use this CSV.
    let datapoints = CSVtoArray(filepath);
    maxfps = maxarr(datapoints);
    // Add y axis labels. Note: 304 pixels worth of height to play with. We will want exactly 10 labels.
    ascent(i in 0..10) {
        // Tick on line
        svg = svg ~ "<path d=\"M 60 " ~ ToString(304 - 300 * i/9) ~ " H 68\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
        // Text Label
        svg = svg ~ "<text x=\"54\" y=\"" ~ ToString(304 - 300 * i/9) ~ "\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"end\" dominant-baseline=\"central\">";
        svg = svg ~ vtos("1.2f", maxfps/9 * i) ~ "FPS";
        svg = svg ~ "</text>";
    }

    // Add paths

    // Close SVG
    svg = svg ~ "</svg>";
    return svg;
}

/* =================================================================================== */
/* ================================ Report Generation ================================ */
/* =================================================================================== */

// Returns the SVG chart with everything except for paths and y axis labels. Helper function.
function SVGChartGen {
    let svg_width = elapsedtime * GRAPH_SCALE / 60 + 96; // By default, a second is one pixel. 64 pixel buffer for left sidebar, 32 for right sidebar
    let svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" ~ ToString(svg_width) ~ "\" height=\"400\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">";
    svg = svg ~ "<path d=\"M 64 304 H " ~ ToString(svg_width) ~ "\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
    svg = svg ~ "<path d=\"M 64 304 V 0\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
    // Plot the labels on the x axis every 48 * GRAPH_SCALE seconds (default, every 48 pixels). Needs to be a multiple of 12 pixels to avoid awful rounding.
    let totaltimesec = elapsedtime / 60;
    let xaxisctr = 0; // Position in time per label
    while (xaxisctr < totaltimesec) {
        // Tick on line
        svg = svg ~ "<path d=\"M " ~ ToString(64 + xaxisctr * GRAPH_SCALE) ~ " 300 V 308\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
        // Text Label
        svg = svg ~ "<text x=\"" ~ ToString(64 + xaxisctr * GRAPH_SCALE) ~ "\" y=\"316\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"middle\" dominant-baseline=\"central\">";
        let minutes = truncate(xaxisctr/60);
        let seconds = truncate(xaxisctr) % 60;
        svg = svg ~ IntToString(minutes) ~ "m" ~ IntToString(seconds) ~ "s";
        svg = svg ~ "</text>";
        xaxisctr += 48 / GRAPH_SCALE;
    }
    return svg;
}

/* *************************************************************************
* CSVtoArray() -- Takes a newline and comma delimited file and converts it to an array.
* Param: filepath (string) - File handle of modified CSV file
* Return: array of string values
************************************************************************* */
function CSVtoArray(filepath) {
    WriteLog("CSVtoArray: Running on " ~ filepath);
    let handle = ObjFile_Create(OBJ_FILE_TEXT);
    let status = ObjFile_Open(handle, filepath);
    while (!status) {
        WriteLog("CSVtoArray: Reading file " ~ filepath ~ " failed.");
        status = ObjFile_Open(handle, filepath);
        yield;
    }
    WriteLog("CSVtoArray: Successfully read file " ~ filepath ~ ".");

    let toreturn = [];
    ascent(i in 0..ObjFileT_GetLineCount(handle)) { // For every line
        let line = ObjFileT_GetLineText(handle, i + 1); // Recall that lines are 1-indexed
        let split = SplitString(line, ",");
        ascent(j in 0..length(split)) {
            if (split[j] != "") {
                toreturn = toreturn ~ [ator(split[j])];
            }
        }
    }
    Obj_Delete(handle);
    return toreturn;
}

task GenerateReport() {
    finished = true;
    yield; //Wait for all tasks fo terminate and flush

    // Begin by creating our output HTML file.
    let outputfilepath = OUTPUT_DIRECTORY ~ player ~ starttime ~ ".html";
    WriteLog("GenerateReport: Will write to " ~ outputfilepath);
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    ObjFile_OpenNW(outputfile, outputfilepath);

    // First, write our headers
    let headerhtml = "<!DOCTYPE html><html lang=\"en-us\"><meta charset=\utf-8\"><title>Danmakufu APM for " ~ SCRIPT_NAME ~ "</title>";
    ObjFileT_AddLine(outputfile, headerhtml);

    // Second, add CSS
    let csshtml = "<style>body {font-family: \"Helvetica\";} .header {padding: 4px; background-color: #4466DD; color: white; border-left: 8px solid #88DDFF;}</style>";
    ObjFileT_AddLine(outputfile, csshtml);

    // Begin body
    let bodystarthtml = "<body>";
    ObjFileT_AddLine(outputfile, bodystarthtml);

    // Write Opening Header
    let openingheaderhtml = "<h1 class=\"header\">Danmakufu APM for script: " ~ SCRIPT_NAME ~ "</h1>" ~
        "<div><p>Start Time: " ~ starttime[0..4] ~ " " ~ starttime[4..6] ~ " " ~ starttime[6..8] ~ " " ~ starttime[8..10] ~ ":" ~ starttime[10..12] ~ ":" ~ starttime[12..14] ~ "</p><p>Player ID: " ~ player ~ "</p></div>";
    ObjFileT_AddLine(outputfile, openingheaderhtml);

    // --------------- Start Reporting ---------------

    if (FEATURE_FPS_ENABLE) {
        while (!finished_fps) {yield;} //Wait for file to be written before reading
        ObjFileT_AddLine(outputfile, "<h3 class=\"header\">FPS Monitoring</h3><p>Note: FPS values recorded here may be lower than usual due to the overhead caused by the APM.</p>");
        ObjFileT_AddLine(outputfile, APM_ChartGenFPS);
    }

    // ---------------  End Reporting  ---------------

    // End Body
    let bodyendhtml = "<body>";
    ObjFileT_AddLine(outputfile, bodyendhtml);

    // End by closing the HTML and writing our output HTML file.
    let endhtml = "</html>";
    ObjFileT_AddLine(outputfile, endhtml);
    ObjFile_Store(outputfile);
    yield;
    Obj_Delete(outputfile);
}

/* ================================================================================== */
/* ================================ Helper Functions ================================ */
/* ================================================================================== */

// Returns max value in array. Assumes string inputs.
// Thankfully DNH allows us to compare strings like so: "3.0" < "2.4"
function maxarr(arr) {
    if (length(arr) == 0) {
        WriteLog("maxarr: Received empty array");
        return -1;
    }
    let maxval = arr[0];
    ascent(i in 0..length(arr)) {
        if (arr[i] >= maxval) {
            maxval = arr[i];
        }
    }
    return ator(maxval);
}

function wait(n) {
    loop(n) {
        yield;
    }
}
