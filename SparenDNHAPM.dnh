/* ******************************************************************
* Sparen's Danmakufu ph3 Application Monitoring System
* For use with Touhou Danmakufu ph3
* (C) Sparen of Iria 2018
****************************************************************** */

/* ******************************************************************
* This script is meant to be run in parallel with a stage script or 
* lower. Set up this system in @Loading of your preferred script
* using LoadScript(), SetCommonData(), and StartScript().
****************************************************************** */

// Global Variables used regardless of which tracking mechanisms are enabled
let currdir = GetCurrentScriptDirectory();
let starttime = GetCurrentDateTimeS(); // Log start time for use in output report
let player = GetPlayerID(); // Player #ID, used in output report

// Variables to be updated
let elapsedtime = 0;
let finished = false;
let finished_fps = false;

// Variables to be customized
let EVENT_DNHAPM_FINALIZE; // Event to call via NotifyEvent/NotifyEventAll when the user wishes to generate the output report.
let OUTPUT_DIRECTORY; // Directory to output the report to
let SCRIPT_NAME; // Name of the script being monitored
let ENABLE_AGGREGATE; // Whether or not to aggregate all data in directory when making graphs
let GRAPH_SCALE; // Scale of the x axis on the graph. To be implemented later.
let AGGREGATE_LINE_OPACITY; // Opacity of the paths representing former data points.

let USER_TEXT; // User defined text

// Feature Set Customization
let FEATURE_FPS_ENABLE; // Enable or disable FPS logging
let FEATURE_FPS_UPDATEFREQ; // Update frequency, in frames.
let FEATURE_FPS_LINECOLOR; // Color of the line, in HTML supported color

@Loading {
    if (!IsCommonDataAreaExists("dnhapm")) {
        CreateCommonDataArea("dnhapm");
    }
}

@Initialize {
    WriteLog("DNHAPM: Now running");
    // Load customizable variables
    EVENT_DNHAPM_FINALIZE = GetAreaCommonData("dnhapm", "FinalizeEvent", EV_USER_STAGE + 2048);
    OUTPUT_DIRECTORY = GetAreaCommonData("dnhapm", "OutputDirectory", currdir ~ "./dnhapm-output/");
    SCRIPT_NAME = GetAreaCommonData("dnhapm", "ScriptName", "--Unnamed Script--");
    ENABLE_AGGREGATE = GetAreaCommonData("dnhapm", "EnableAggregate", true);
    GRAPH_SCALE = GetAreaCommonData("dnhapm", "GraphScale", 1);
    AGGREGATE_LINE_OPACITY = GetAreaCommonData("dnhapm", "AggregateLineOpacity", 0.25);

    USER_TEXT = GetAreaCommonData("dnhapm", "UserText", "");

    FEATURE_FPS_ENABLE = GetAreaCommonData("dnhapm", "FPSEnable", true);
    FEATURE_FPS_UPDATEFREQ = GetAreaCommonData("dnhapm", "FPSUpdateFreq", 10);
    FEATURE_FPS_LINECOLOR = GetAreaCommonData("dnhapm", "FPSLineColor", "#2266FF");

    //Initialize non-event based trackers
    if (FEATURE_FPS_ENABLE) {
        APM_StartFPS;
    }
}

// We must catch all notable events.
@Event {
    alternative(GetEventType())
    case(EVENT_DNHAPM_FINALIZE) {
        GenerateReport;
    }
}

@MainLoop {
    elapsedtime += 1; // update counter
    yield;
}

/* ============================================================================= */
/* ================================ FPS Logging ================================ */
/* ============================================================================= */
task APM_StartFPS {
    // Create output file
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    let outputfilepath = OUTPUT_DIRECTORY ~ "apmfps-" ~ starttime ~ ".csv";
    ObjFile_OpenNW(outputfile, outputfilepath);
    let csvlog = ""; // CSV log
    let counter = 0;
    while(!finished) {
        let cfps = GetCurrentFps();
        csvlog = csvlog ~ vtos("1.2f", cfps) ~ ",";
        // If csvlog is getting too long, push it to the File Object
        if (counter % 128 == 0) {
            ObjFileT_AddLine(outputfile, csvlog);
            csvlog = "";
        }
        counter += 1;
        loop(FEATURE_FPS_UPDATEFREQ){yield;}
    }
    // Flush to file
    ObjFileT_AddLine(outputfile, csvlog);
    ObjFile_Store(outputfile);
    WriteLog("APM_StartFPS: Wrote CSV to " ~ outputfilepath);
    Obj_Delete(outputfile);
    // yield once before marking as complete
    yield;
    finished_fps = true;
    WriteLog("APM_StartFPSDEBUG: Finished");
}

// Returns the SVG chart for FPS in its entirety.
function APM_ChartGenFPS {
    WriteLog("APM_ChartGenFPS: Starting.");
    let paths = [];
    // First, we will determine the scale of the x and y axes and log all of the necessary files.
    let maxfps = 0; // Maximum FPS 
    let maxtime = 0; // Number of DATA POINTS collected - will be scaled later
    let currfilepath = OUTPUT_DIRECTORY ~ "apmfps-" ~ starttime ~ ".csv"; // Current run, for later reference
    let filepathlist = GetFilePathList(OUTPUT_DIRECTORY);
    ascent(i in 0..length(filepathlist)) {
        // First, retrieve the file name
        let filename = parseFileName(filepathlist[i]);
        //WriteLog("APM_ChartGenFPS DEBUG: testing on " ~ filename);
        // We only read the file if aggregating and a fps file, or if it's the file we just set up.
        if (filename[0..6] == "apmfps" && ENABLE_AGGREGATE || (filename == currfilepath)) {
            //WriteLog("APM_ChartGenFPS DEBUG: running on " ~ filename);
            // See if this one sets a new maxfps
            let filedatapoints = CSVtoArray(filepathlist[i]);
            let filemaxfps = maxarr(filedatapoints);
            if (filemaxfps > maxfps) {maxfps = filemaxfps;}
            // See if this one sets a new maxtime
            if (length(filedatapoints) > maxtime) {maxtime = length(filedatapoints);}
            // Generate path. If filepathlist[i] is the current file, then opacity is set to 1, AGGREGATE_LINE_OPACITY otherwise.
            let opacity = 1;
            if (filepathlist[i] != currfilepath) {opacity = AGGREGATE_LINE_OPACITY;}
            let newpath = "<path d=\"M 64 304 ";
            // Iterate over the data points. Recall that by default, a second is one pixel.
            // Also recall that each data point is FEATURE_FPS_UPDATEFREQ frames apart.
            let basex = 64;
            ascent(j in 0..length(filedatapoints)) {
                let nodex = basex + j * FEATURE_FPS_UPDATEFREQ/60 * GRAPH_SCALE;
                let nodey = 304 - 300 * ator(filedatapoints[j])/maxfps;
                newpath = newpath ~ "L " ~ ToString(nodex) ~ " " ~ ToString(nodey) ~ " ";
            }
            newpath = newpath ~ "\" stroke=\"" ~ FEATURE_FPS_LINECOLOR ~ "\" stroke-width=\"1\" fill=\"none\" opacity=\"" ~ ToString(opacity) ~ "\"></path>";
            paths = paths ~ [newpath];
        }
    }
    // Chart Basics 
    let svg = SVGChartGen(maxtime * FEATURE_FPS_UPDATEFREQ/60);
    // X Axis Labels
    svg = svg ~ SVGXAxisGen(maxtime * FEATURE_FPS_UPDATEFREQ/60);
    // Y Axis Labels
    svg = svg ~ SVGYAxisGen(maxfps, "FPS");
    // Add paths
    ascent(i in 0..length(paths)) {
        svg = svg ~ paths[i];
    }
    // Close SVG
    svg = svg ~ "</svg>";
    svg = svg ~ "<p>Logged a maximum of " ~ IntToString(maxtime) ~ " data points spanning " ~ ToString(maxtime * FEATURE_FPS_UPDATEFREQ/60) ~ " seconds.</p>";
    svg = svg ~ "<p>Logged a maximum FPS of " ~ vtos("1.2f", maxfps) ~ ".</p>";  
    return svg;
}

/* =================================================================================== */
/* ================================ Report Generation ================================ */
/* =================================================================================== */

// Returns the SVG chart header. Helper function.
// Takes the amount of time to display on the graph in seconds.
function SVGChartGen(time) {
    let svg_width = time * GRAPH_SCALE + 128; // By default, a second is one pixel. 64 pixel buffer for left sidebar, 64 for right sidebar
    let svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" ~ ToString(svg_width) ~ "\" height=\"320\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">";
    svg = svg ~ "<path d=\"M 64 304 H " ~ ToString(svg_width) ~ "\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
    svg = svg ~ "<path d=\"M 64 304 V 0\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
    return svg;
}

// Returns the x axis with as many 48-pixel spaced labels as possible. Helper function.
// Takes the amount of time to display on the graph in seconds.
function SVGXAxisGen(time) {
    let svg = "";
    // Plot the labels on the x axis every 48 * GRAPH_SCALE seconds (default, every 48 pixels). Needs to be a multiple of 12 pixels to avoid awful rounding.
    let totaltimesec = time * GRAPH_SCALE; // Number of pixels we can draw in
    let xaxisctr = 0; // Position in time per label. Unit is NOT pixels.
    while (xaxisctr * GRAPH_SCALE < totaltimesec) {
        // Tick on line
        svg = svg ~ "<path d=\"M " ~ ToString(64 + xaxisctr * GRAPH_SCALE) ~ " 302 V 308\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
        // Text Label
        svg = svg ~ "<text x=\"" ~ ToString(64 + xaxisctr * GRAPH_SCALE) ~ "\" y=\"316\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"middle\" dominant-baseline=\"central\">";
        let minutes = truncate(xaxisctr/60);
        let seconds = truncate(xaxisctr) % 60;
        svg = svg ~ IntToString(minutes) ~ "m" ~ IntToString(seconds) ~ "s";
        svg = svg ~ "</text>";
        xaxisctr += 48 / GRAPH_SCALE;
    }
    return svg;
}

// Returns the y axis with labels. Helper function.
// Takes the max value (for label scaling) and a supplementary label.
function SVGYAxisGen(maxval, label) {
    let svg = "";
    // Add y axis labels. Note: 304 pixels worth of height to play with. We will want exactly 10 labels.
    ascent(i in 0..10) {
        // Tick on line
        svg = svg ~ "<path d=\"M 60 " ~ ToString(304 - 300 * i/9) ~ " H 66\" stroke=\"#AAAAAA\" stroke-width=\"1\" fill=\"none\"></path>";
        // Text Label
        svg = svg ~ "<text x=\"54\" y=\"" ~ ToString(304 - 300 * i/9) ~ "\" font-family=\"Andale Mono, Monospace\" font-size=\"10px\" fill=\"#222222\" text-anchor=\"end\" dominant-baseline=\"central\">";
        svg = svg ~ vtos("1.2f", maxval/9 * i) ~ label;
        svg = svg ~ "</text>";
    }
    return svg;
}

/* *************************************************************************
* CSVtoArray() -- Takes a newline and comma delimited file and converts it to an array.
* Param: filepath (string) - File handle of modified CSV file
* Return: array of string values
************************************************************************* */
function CSVtoArray(filepath) {
    WriteLog("CSVtoArray: Running on " ~ filepath);
    let handle = ObjFile_Create(OBJ_FILE_TEXT);
    let status = ObjFile_Open(handle, filepath);
    while (!status) {
        WriteLog("CSVtoArray: Reading file " ~ filepath ~ " failed.");
        status = ObjFile_Open(handle, filepath);
        yield;
    }
    WriteLog("CSVtoArray: Successfully read file " ~ filepath ~ ".");

    let toreturn = [];
    ascent(i in 0..ObjFileT_GetLineCount(handle)) { // For every line
        let line = ObjFileT_GetLineText(handle, i + 1); // Recall that lines are 1-indexed
        let split = SplitString(line, ",");
        ascent(j in 0..length(split)) {
            if (split[j] != "") {
                toreturn = toreturn ~ [ator(split[j])];
            }
        }
    }
    Obj_Delete(handle);
    return toreturn;
}

task GenerateReport() {
    finished = true;
    yield; //Wait for all tasks fo terminate and flush

    // Begin by creating our output HTML file.
    let outputfilepath = OUTPUT_DIRECTORY ~ player ~ starttime ~ ".html";
    WriteLog("GenerateReport: Will write to " ~ outputfilepath);
    let outputfile = ObjFile_Create(OBJ_FILE_TEXT);
    ObjFile_OpenNW(outputfile, outputfilepath);

    // First, write our headers
    let headerhtml = "<!DOCTYPE html><html lang=\"en-us\"><meta charset=\utf-8\"><title>Danmakufu APM for " ~ SCRIPT_NAME ~ "</title>";
    ObjFileT_AddLine(outputfile, headerhtml);

    // Second, add CSS
    let csshtml = "<style>body {font-family: \"Helvetica\";} .header {padding: 4px; background-color: #4466DD; color: white; border-left: 8px solid #88DDFF;}</style>";
    ObjFileT_AddLine(outputfile, csshtml);

    // Begin body
    let bodystarthtml = "<body>";
    ObjFileT_AddLine(outputfile, bodystarthtml);

    // Write Opening Header
    let openingheaderhtml = "<h1 class=\"header\">Danmakufu APM for script: " ~ SCRIPT_NAME ~ "</h1>" ~
        "<div><p>Start Time: " ~ starttime[0..4] ~ " " ~ starttime[4..6] ~ " " ~ starttime[6..8] ~ " " ~ starttime[8..10] ~ ":" ~ starttime[10..12] ~ ":" ~ starttime[12..14] ~ "</p><p>Player ID: " ~ player ~ "</p></div>";
    openingheaderhtml = openingheaderhtml ~ ToString(USER_TEXT);
    ObjFileT_AddLine(outputfile, openingheaderhtml);

    // --------------- Start Reporting ---------------

    if (FEATURE_FPS_ENABLE) {
        while (!finished_fps) {yield;} //Wait for file to be written before reading
        ObjFileT_AddLine(outputfile, "<h3 class=\"header\">FPS Monitoring</h3><p>Note: FPS values recorded here may be lower than usual due to the overhead caused by the APM.</p>");
        ObjFileT_AddLine(outputfile, APM_ChartGenFPS);
    }

    // ---------------  End Reporting  ---------------

    // End Body
    let bodyendhtml = "<body>";
    ObjFileT_AddLine(outputfile, bodyendhtml);

    // End by closing the HTML and writing our output HTML file.
    let endhtml = "</html>";
    ObjFileT_AddLine(outputfile, endhtml);
    ObjFile_Store(outputfile);
    yield;
    Obj_Delete(outputfile);
}

/* ================================================================================== */
/* ================================ Helper Functions ================================ */
/* ================================================================================== */

// Returns max value in array. Assumes string inputs.
// Thankfully DNH allows us to compare strings like so: "3.0" < "2.4"
function maxarr(arr) {
    if (length(arr) == 0) {
        WriteLog("maxarr: Received empty array");
        return -1;
    }
    let maxval = arr[0];
    ascent(i in 0..length(arr)) {
        if (arr[i] >= maxval) {
            maxval = arr[i];
        }
    }
    return ator(maxval);
}

function wait(n) {
    loop(n) {
        yield;
    }
}

function parseFileName(filepath) {
    // Essentially, split by /, get last
    let pathunits = SplitString(filepath, "/");
    return pathunits[length(pathunits) - 1];
}